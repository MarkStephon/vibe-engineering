name: Vibe Continuous - 24å°æ—¶è‡ªåŠ¨è¿­ä»£å¼•æ“

on:
  # æ¯å°æ—¶è¿è¡Œä¸€æ¬¡ï¼ŒæŒç»­æ£€æµ‹
  schedule:
    - cron: '0 * * * *'
  # æ”¯æŒæ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'æŒ‡å®šæ£€æµ‹çš„ Issue ç¼–å·ï¼ˆç•™ç©ºåˆ™æ£€æµ‹æ‰€æœ‰ï¼‰'
        required: false
        type: string
      mode:
        description: 'è¿è¡Œæ¨¡å¼'
        required: true
        default: 'scan'
        type: choice
        options:
          - scan        # æ‰«ææ‰€æœ‰è¿›è¡Œä¸­çš„ issue
          - check       # æ£€æµ‹æŒ‡å®š issue å®Œæˆåº¦
          - continue    # ç»§ç»­å¤„ç†æœªå®Œæˆä»»åŠ¡
          - verify      # éªŒæ”¶æ¨¡å¼ï¼šæ£€æµ‹å®Œæˆåº¦ï¼Œé€šè¿‡åˆ™å…³é—­ issue

jobs:
  continuous-iteration:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      pull-requests: read
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Scan and Continue Issues
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const mode = '${{ github.event.inputs.mode }}' || 'scan';
            const specificIssue = '${{ github.event.inputs.issue_number }}';
            const now = new Date();

            console.log("=".repeat(60));
            console.log("ğŸ”„ VIBE CONTINUOUS - 24å°æ—¶è‡ªåŠ¨è¿­ä»£å¼•æ“");
            console.log("=".repeat(60));
            console.log(`æ—¶é—´: ${now.toISOString()}`);
            console.log(`æ¨¡å¼: ${mode}`);
            if (specificIssue) console.log(`æŒ‡å®š Issue: #${specificIssue}`);

            // è¯»å–é…ç½®
            let config;
            try {
              const configContent = fs.readFileSync('.github/config/workflow-config.json', 'utf8');
              config = JSON.parse(configContent);
            } catch (error) {
              console.warn(`âš ï¸ æ— æ³•è¯»å–é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
              config = {
                continuous: {
                  check_interval_hours: 1,
                  max_iterations_per_issue: 10,
                  completion_check_model: "google/gemini-2.0-flash-001"
                }
              };
            }

            // è·å–éœ€è¦æ£€æµ‹çš„ Issues
            async function getTargetIssues() {
              if (specificIssue) {
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(specificIssue)
                });
                return [issue];
              }

              // è·å–æ‰€æœ‰å¤„äºå¼€å‘ä¸­çš„ issue
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // è¿‡æ»¤å‡ºéœ€è¦æ£€æµ‹çš„ issue
              // æ¡ä»¶ï¼šæœ‰éªŒæ”¶æ ‡å‡† + æœ‰ PR æˆ–æ­£åœ¨å¤„ç†ä¸­
              return issues.filter(issue => {
                const labels = issue.labels.map(l => l.name);
                const body = issue.body || '';

                // å¿…é¡»æœ‰éªŒæ”¶æ ‡å‡†
                const hasAcceptanceCriteria =
                  body.includes('éªŒæ”¶æ ‡å‡†') ||
                  body.includes('Acceptance Criteria') ||
                  body.includes('## âœ…') ||
                  body.includes('- [ ]');

                // å¿…é¡»æ˜¯è¿›è¡Œä¸­æˆ–å·²æœ‰ PR
                const isInProgress =
                  labels.includes('ğŸ¤– ai-processing') ||
                  labels.includes('âœ… ai-completed') ||
                  labels.some(l => l.includes('complexity:'));

                // æ’é™¤å·²å…³é—­å’Œè·³è¿‡çš„
                const shouldSkip =
                  labels.includes('skip-vibe') ||
                  labels.includes('needs-triage') ||
                  issue.title.startsWith('[PRD]');

                return hasAcceptanceCriteria && isInProgress && !shouldSkip;
              });
            }

            // è§£æéªŒæ”¶æ ‡å‡†
            function parseAcceptanceCriteria(body) {
              const criteria = [];
              const lines = body.split('\n');
              let inCriteriaSection = false;

              for (const line of lines) {
                // æ£€æµ‹éªŒæ”¶æ ‡å‡†åŒºå—
                if (line.includes('éªŒæ”¶æ ‡å‡†') || line.includes('Acceptance Criteria') || line.includes('## âœ…')) {
                  inCriteriaSection = true;
                  continue;
                }

                // é‡åˆ°æ–°çš„æ ‡é¢˜ç»“æŸåŒºå—
                if (inCriteriaSection && line.startsWith('## ') && !line.includes('âœ…')) {
                  inCriteriaSection = false;
                  continue;
                }

                // æå– checkbox é¡¹ç›®
                const checkboxMatch = line.match(/^[\s-]*\[([x ])\]\s*(.+)/i);
                if (checkboxMatch) {
                  criteria.push({
                    completed: checkboxMatch[1].toLowerCase() === 'x',
                    text: checkboxMatch[2].trim()
                  });
                }
              }

              // å¦‚æœæ²¡æ‰¾åˆ°ä¸“é—¨çš„éªŒæ”¶æ ‡å‡†åŒºå—ï¼Œæœç´¢æ•´ä¸ªæ–‡æ¡£çš„ checkbox
              if (criteria.length === 0) {
                const allCheckboxes = body.match(/\[([x ])\]\s*(.+)/gi) || [];
                for (const match of allCheckboxes) {
                  const m = match.match(/\[([x ])\]\s*(.+)/i);
                  if (m) {
                    criteria.push({
                      completed: m[1].toLowerCase() === 'x',
                      text: m[2].trim()
                    });
                  }
                }
              }

              return criteria;
            }

            // è·å– issue ç›¸å…³çš„ PR
            async function getRelatedPRs(issueNumber) {
              try {
                const { data: events } = await github.rest.issues.listEventsForTimeline({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });

                const prNumbers = new Set();
                for (const event of events) {
                  if (event.event === 'cross-referenced' && event.source?.issue?.pull_request) {
                    prNumbers.add(event.source.issue.number);
                  }
                }

                const prs = [];
                for (const prNumber of prNumbers) {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  prs.push(pr);
                }

                return prs;
              } catch (error) {
                console.warn(`âš ï¸ è·å–å…³è” PR å¤±è´¥: ${error.message}`);
                return [];
              }
            }

            // æ£€æŸ¥ PR çš„ CI çŠ¶æ€
            async function getPRStatus(prNumber) {
              try {
                const { data: checks } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/pull/${prNumber}/head`
                });

                const status = {
                  total: checks.check_runs.length,
                  success: 0,
                  failure: 0,
                  pending: 0
                };

                for (const check of checks.check_runs) {
                  if (check.conclusion === 'success') status.success++;
                  else if (check.conclusion === 'failure') status.failure++;
                  else status.pending++;
                }

                return status;
              } catch (error) {
                return { total: 0, success: 0, failure: 0, pending: 0 };
              }
            }

            // ç›´æ¥åŸºäº checkbox çŠ¶æ€è¯„ä¼°å®Œæˆåº¦ï¼ˆä¸ä½¿ç”¨ AIï¼‰
            function evaluateCompletion(issue, criteria) {
              const completed = criteria.filter(c => c.completed).length;
              const total = criteria.length;
              const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

              const completedItems = criteria.filter(c => c.completed).map(c => c.text);
              const pendingItems = criteria.filter(c => !c.completed).map(c => c.text);

              // æ ¹æ®ä»»åŠ¡å¤æ‚åº¦æ¨è agent ç±»å‹
              let agentType = 'medium';
              if (pendingItems.length <= 2) {
                agentType = 'simple';
              } else if (pendingItems.length > 5) {
                agentType = 'complex';
              }

              return {
                completion_percentage: percentage,
                completed_items: completedItems,
                pending_items: pendingItems,
                blocking_issues: [],
                next_action: percentage < 100 ? `ç»§ç»­å®Œæˆå‰©ä½™ ${pendingItems.length} é¡¹ä»»åŠ¡` : "æ‰€æœ‰éªŒæ”¶æ ‡å‡†å·²æ»¡è¶³",
                should_continue: percentage < 100,
                agent_type: agentType
              };
            }

            // ä» Agent è¯„è®ºä¸­è§£æå·²å®Œæˆçš„éªŒæ”¶é¡¹
            async function parseAgentCompletionFromComments(issueNumber, criteria) {
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  per_page: 50
                });

                // æŸ¥æ‰¾æœ€è¿‘çš„ Claude/Agent å®ŒæˆæŠ¥å‘Šï¼ˆåŒ…å« "Claude finished" æˆ– "âœ…" éªŒæ”¶æ ‡è®°ï¼‰
                const agentComments = comments.filter(c =>
                  c.body && (
                    c.body.includes('Claude finished') ||
                    c.body.includes('Status: COMPLETE') ||
                    c.body.includes('**Status: COMPLETE') ||
                    (c.body.includes('éªŒæ”¶æ ‡å‡†') && c.body.includes('âœ…'))
                  )
                );

                if (agentComments.length === 0) {
                  console.log(`    ğŸ“ æœªæ‰¾åˆ° Agent å®ŒæˆæŠ¥å‘Šè¯„è®º`);
                  return null;
                }

                // å–æœ€è¿‘çš„ä¸€æ¡
                const latestComment = agentComments[agentComments.length - 1];
                const commentBody = latestComment.body;

                console.log(`    ğŸ“ æ‰¾åˆ° Agent å®ŒæˆæŠ¥å‘Š (è¯„è®º ID: ${latestComment.id})`);

                // æ£€æŸ¥è¯„è®ºä¸­æ˜¯å¦è¡¨æ˜æ‰€æœ‰éªŒæ”¶æ ‡å‡†éƒ½å·²å®Œæˆ
                const allCriteriaCompleted = [];

                for (const criterion of criteria) {
                  // åœ¨è¯„è®ºä¸­æŸ¥æ‰¾è¯¥éªŒæ”¶æ ‡å‡†æ˜¯å¦è¢«æ ‡è®°ä¸ºå®Œæˆ
                  // åŒ¹é…æ¨¡å¼ï¼šâœ… æˆ– [x] åé¢è·Ÿç€éªŒæ”¶æ ‡å‡†æ–‡æœ¬
                  const criterionText = criterion.text.toLowerCase();
                  const commentLower = commentBody.toLowerCase();

                  // æ£€æŸ¥å¤šç§å®Œæˆæ ‡è®°æ¨¡å¼
                  const isMarkedComplete =
                    // æ£€æŸ¥æ˜¯å¦æœ‰ âœ… æ ‡è®°ä¸”åŒ…å«å…³é”®è¯
                    (commentBody.includes('âœ…') && commentLower.includes(criterionText.substring(0, 20))) ||
                    // æ£€æŸ¥æ˜¯å¦åœ¨ [x] åˆ—è¡¨ä¸­
                    commentBody.match(new RegExp(`\\[x\\]\\s*${criterion.text.substring(0, 20).replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i')) ||
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ç¡®çš„å®Œæˆå£°æ˜
                    (commentLower.includes('complete') && commentLower.includes(criterionText.substring(0, 15))) ||
                    (commentLower.includes('å·²å®Œæˆ') && commentLower.includes(criterionText.substring(0, 15))) ||
                    (commentLower.includes('å·²å®ç°') && commentLower.includes(criterionText.substring(0, 15)));

                  if (isMarkedComplete) {
                    allCriteriaCompleted.push(criterion.text);
                  }
                }

                // å¦‚æœè¯„è®ºä¸­æ˜ç¡®è¡¨ç¤º "all requirements" æˆ– "100%" å®Œæˆ
                if (
                  commentBody.includes('all requirements have already been implemented') ||
                  commentBody.includes('All acceptance criteria') ||
                  commentBody.includes('æ‰€æœ‰éªŒæ”¶æ ‡å‡†å·²æ»¡è¶³') ||
                  commentBody.includes('Status: COMPLETE')
                ) {
                  console.log(`    âœ… Agent æŠ¥å‘Šæ‰€æœ‰éªŒæ”¶æ ‡å‡†å·²å®Œæˆ`);
                  return criteria.map(c => c.text);
                }

                if (allCriteriaCompleted.length > 0) {
                  console.log(`    âœ… ä»è¯„è®ºä¸­è¯†åˆ«åˆ° ${allCriteriaCompleted.length} ä¸ªå·²å®Œæˆé¡¹`);
                  return allCriteriaCompleted;
                }

                return null;
              } catch (error) {
                console.error(`    âŒ è§£æ Agent è¯„è®ºå¤±è´¥: ${error.message}`);
                return null;
              }
            }

            // æ›´æ–° Issue body ä¸­çš„ checkbox çŠ¶æ€
            async function updateIssueCheckboxes(issueNumber, issueBody, completedItems) {
              let updatedBody = issueBody;
              let updateCount = 0;

              for (const item of completedItems) {
                // è½¬ä¹‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦
                const escapedItem = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // åŒ¹é…æœªå‹¾é€‰çš„ checkbox
                const uncheckedPattern = new RegExp(`- \\[ \\]\\s*${escapedItem}`, 'gi');

                if (uncheckedPattern.test(updatedBody)) {
                  updatedBody = updatedBody.replace(uncheckedPattern, `- [x] ${item}`);
                  updateCount++;
                }
              }

              if (updateCount > 0) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: updatedBody
                });
                console.log(`    ğŸ“ å·²æ›´æ–° ${updateCount} ä¸ª checkbox ä¸ºå·²å®Œæˆ`);
                return updatedBody;
              }

              return issueBody;
            }

            // è§¦å‘ Agent ç»§ç»­å¤„ç†
            async function triggerContinuation(issue, evaluation) {
              // æ£€æŸ¥è¿­ä»£æ¬¡æ•°é™åˆ¶
              const iterationMatch = issue.body?.match(/<!-- vibe-iteration: (\d+) -->/);
              const currentIteration = iterationMatch ? parseInt(iterationMatch[1]) : 0;
              const maxIterations = config.continuous?.max_iterations_per_issue || 10;

              if (currentIteration >= maxIterations) {
                console.log(`âš ï¸ Issue #${issue.number} å·²è¾¾æœ€å¤§è¿­ä»£æ¬¡æ•° (${maxIterations})`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    "âš ï¸ **è‡ªåŠ¨è¿­ä»£å·²è¾¾ä¸Šé™**",
                    "",
                    `æ­¤ä»»åŠ¡å·²è‡ªåŠ¨è¿­ä»£ ${maxIterations} æ¬¡ï¼Œéœ€è¦äººå·¥ä»‹å…¥ã€‚`,
                    "",
                    `**å½“å‰å®Œæˆåº¦**: ${evaluation.completion_percentage}%`,
                    "",
                    "**æœªå®Œæˆé¡¹ç›®**:",
                    evaluation.pending_items.map(p => `- ${p}`).join('\n'),
                    "",
                    "---",
                    "> ğŸ” ç”± Vibe Continuous æ£€æµ‹"
                  ].join("\n")
                });

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-review', 'âš ï¸ iteration-limit']
                });

                return false;
              }

              // æ„å»ºç»§ç»­å¤„ç†çš„ä¸Šä¸‹æ–‡
              const continuationContext = `è¿­ä»£#${currentIteration + 1}: å®Œæˆåº¦${evaluation.completion_percentage}%, å¾…å®Œæˆ: ${evaluation.pending_items.slice(0, 3).join('; ')}`;

              const continuationPrompt = [
                `## ğŸ”„ è‡ªåŠ¨è¿­ä»£ #${currentIteration + 1}`,
                "",
                "**å®Œæˆåº¦æ£€æµ‹ç»“æœ**:",
                `- å½“å‰è¿›åº¦: ${evaluation.completion_percentage}%`,
                `- å·²å®Œæˆ: ${evaluation.completed_items.length} é¡¹`,
                `- å¾…å®Œæˆ: ${evaluation.pending_items.length} é¡¹`,
                "",
                "**å¾…å®Œæˆé¡¹ç›®**:",
                evaluation.pending_items.map(p => `- [ ] ${p}`).join('\n'),
                "",
                "**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:",
                evaluation.next_action,
                "",
                "---",
                "> ğŸ”„ ç”± Vibe Continuous è‡ªåŠ¨è§¦å‘ workflow_dispatch"
              ].join("\n");

              // æ›´æ–° issue body ä¸­çš„è¿­ä»£è®¡æ•°
              const newBody = issue.body?.includes('<!-- vibe-iteration:')
                ? issue.body.replace(/<!-- vibe-iteration: \d+ -->/, `<!-- vibe-iteration: ${currentIteration + 1} -->`)
                : `${issue.body || ''}\n\n<!-- vibe-iteration: ${currentIteration + 1} -->`;

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: newBody
              });

              // å‘å¸ƒçŠ¶æ€è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: continuationPrompt
              });

              // ç›´æ¥è§¦å‘ agent workflowï¼ˆä½¿ç”¨ workflow_dispatchï¼‰
              const agentWorkflow = evaluation.agent_type === 'simple' ? 'agent-simple.yml' :
                                    evaluation.agent_type === 'complex' ? 'agent-complex.yml' : 'agent-medium.yml';

              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: agentWorkflow,
                  ref: 'main',
                  inputs: {
                    issue_number: String(issue.number),
                    continuation_context: continuationContext
                  }
                });
                console.log(`âœ… å·²é€šè¿‡ workflow_dispatch è§¦å‘ ${agentWorkflow} å¤„ç† Issue #${issue.number} (ç¬¬ ${currentIteration + 1} æ¬¡è¿­ä»£)`);
              } catch (dispatchError) {
                console.error(`âŒ è§¦å‘ ${agentWorkflow} å¤±è´¥: ${dispatchError.message}`);
                return false;
              }

              return true;
            }

            // ä¸»é€»è¾‘
            const targetIssues = await getTargetIssues();
            console.log(`\nğŸ“‹ æ‰¾åˆ° ${targetIssues.length} ä¸ªéœ€è¦æ£€æµ‹çš„ Issue\n`);

            const results = {
              checked: 0,
              completed: 0,
              continued: 0,
              skipped: 0
            };

            for (const issue of targetIssues) {
              console.log(`\n${"â”€".repeat(50)}`);
              console.log(`ğŸ“Œ Issue #${issue.number}: ${issue.title}`);

              // è§£æéªŒæ”¶æ ‡å‡†
              const criteria = parseAcceptanceCriteria(issue.body || '');
              if (criteria.length === 0) {
                console.log(`  â­ï¸ è·³è¿‡: æ— å¯è¯†åˆ«çš„éªŒæ”¶æ ‡å‡†`);
                results.skipped++;
                continue;
              }

              console.log(`  ğŸ“‹ éªŒæ”¶æ ‡å‡†: ${criteria.length} é¡¹`);
              console.log(`  âœ… å·²å®Œæˆ: ${criteria.filter(c => c.completed).length} é¡¹`);

              // è·å–å…³è” PR
              const relatedPRs = await getRelatedPRs(issue.number);
              let prInfo = '';

              if (relatedPRs.length > 0) {
                const prDetails = [];
                for (const pr of relatedPRs) {
                  const status = await getPRStatus(pr.number);
                  prDetails.push(`PR #${pr.number}: ${pr.state} (CI: ${status.success}/${status.total} é€šè¿‡)`);
                }
                prInfo = prDetails.join('\n');
                console.log(`  ğŸ”— å…³è” PR: ${relatedPRs.length} ä¸ª`);
              }

              // ğŸ”‘ å…³é”®æ­¥éª¤ï¼šå…ˆä» Agent è¯„è®ºä¸­è§£æå·²å®Œæˆé¡¹ï¼Œæ›´æ–° Issue body çš„ checkbox
              let currentBody = issue.body || '';
              const agentCompletedItems = await parseAgentCompletionFromComments(issue.number, criteria);

              if (agentCompletedItems && agentCompletedItems.length > 0) {
                // æ›´æ–° Issue body ä¸­çš„ checkbox
                currentBody = await updateIssueCheckboxes(issue.number, currentBody, agentCompletedItems);

                // é‡æ–°è§£ææ›´æ–°åçš„éªŒæ”¶æ ‡å‡†
                const updatedCriteria = parseAcceptanceCriteria(currentBody);
                if (updatedCriteria.length > 0) {
                  criteria.length = 0;
                  criteria.push(...updatedCriteria);
                }
              }

              // åŸºäº checkbox çŠ¶æ€è¯„ä¼°å®Œæˆåº¦ï¼ˆç›´æ¥çœ‹ Issue body ä¸­çš„ checkboxï¼‰
              const evaluation = evaluateCompletion(issue, criteria);
              console.log(`  ğŸ“Š Checkbox å®Œæˆåº¦: ${evaluation.completion_percentage}%`);
              results.checked++;

              // åˆ¤æ–­æ˜¯å¦éœ€è¦ç»§ç»­
              if (evaluation.completion_percentage >= 100) {
                console.log(`  âœ… ä»»åŠ¡å·²å®Œæˆï¼`);
                results.completed++;

                // æ·»åŠ å®Œæˆæ ‡ç­¾
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['âœ… verified']
                });

                // éªŒæ”¶æ¨¡å¼ä¸‹ï¼šæ›´æ–°éªŒæ”¶æ ‡å‡† checkbox å¹¶å…³é—­ issue
                if (mode === 'verify') {
                  console.log(`  ğŸ“ éªŒæ”¶æ¨¡å¼ï¼šæ›´æ–°éªŒæ”¶æ ‡å‡†å¹¶å…³é—­ issue`);

                  // æ›´æ–° issue body ä¸­çš„ checkbox ä¸ºå·²å®Œæˆ
                  let updatedBody = issue.body || '';
                  for (const item of evaluation.completed_items) {
                    // å°è¯•åŒ¹é…å¹¶æ›´æ–° checkbox
                    const escapedItem = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const uncheckedPattern = new RegExp(`- \\[ \\]\\s*${escapedItem}`, 'gi');
                    updatedBody = updatedBody.replace(uncheckedPattern, `- [x] ${item}`);
                  }

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: updatedBody
                  });

                  // ç§»é™¤è¿›è¡Œä¸­çš„æ ‡ç­¾
                  const labelsToRemove = ['ğŸ¤– ai-processing', 'âŒ ai-failed', 'needs-review', 'agent:medium', 'agent:simple', 'agent:complex'];
                  for (const label of labelsToRemove) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: label
                      });
                    } catch (e) {}
                  }

                  // æ£€æŸ¥æ˜¯å¦æ˜¯ sub-issueï¼ˆä¾èµ–é“¾ä¸­çš„å­ä»»åŠ¡ï¼‰
                  const issueLabels = issue.labels.map(l => l.name);
                  const isSubIssue = issueLabels.includes('sub-issue');

                  if (isSubIssue) {
                    // sub-issue éªŒæ”¶é€šè¿‡åè‡ªåŠ¨å…³é—­ï¼Œä»¥è§¦å‘ä¾èµ–é“¾ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ¡
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: [
                        "## âœ… éªŒæ”¶é€šè¿‡",
                        "",
                        `**å®Œæˆåº¦**: ${evaluation.completion_percentage}%`,
                        "",
                        "**å·²å®Œæˆé¡¹ç›®**:",
                        evaluation.completed_items.map(i => `- [x] ${i}`).join('\n'),
                        "",
                        "æ­¤ Issue ä¸ºå­ä»»åŠ¡ï¼ŒéªŒæ”¶é€šè¿‡åè‡ªåŠ¨å…³é—­ä»¥è§¦å‘ä¾èµ–é“¾ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚",
                        "",
                        "---",
                        "> ğŸ” ç”± Vibe Continuous è‡ªåŠ¨éªŒæ”¶"
                      ].join("\n")
                    });

                    // è‡ªåŠ¨å…³é—­ sub-issue
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      state: 'closed'
                    });

                    console.log(`  ğŸ‰ Sub-Issue #${issue.number} éªŒæ”¶é€šè¿‡ï¼Œå·²è‡ªåŠ¨å…³é—­`);

                  } else {
                    // é sub-issue éœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: [
                        "## âœ… éªŒæ”¶é€šè¿‡",
                        "",
                        `**å®Œæˆåº¦**: ${evaluation.completion_percentage}%`,
                        "",
                        "**å·²å®Œæˆé¡¹ç›®**:",
                        evaluation.completed_items.map(i => `- [x] ${i}`).join('\n'),
                        "",
                        "æ‰€æœ‰éªŒæ”¶æ ‡å‡†å·²æ»¡è¶³ï¼Œè¯·ç¡®è®¤åå…³é—­æ­¤ Issueã€‚",
                        "",
                        "---",
                        "> ğŸ” ç”± Vibe Continuous è‡ªåŠ¨éªŒæ”¶"
                      ].join("\n")
                    });

                    // æ·»åŠ ç­‰å¾…ç¡®è®¤æ ‡ç­¾
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: ['ğŸ“‹ pending-confirmation']
                    });

                    console.log(`  ğŸ‰ Issue #${issue.number} éªŒæ”¶é€šè¿‡ï¼Œç­‰å¾…ç”¨æˆ·æœ€ç»ˆç¡®è®¤`);
                  }
                }

              } else if (evaluation.should_continue && (mode === 'scan' || mode === 'continue')) {
                // è§¦å‘ç»§ç»­è¿­ä»£ï¼ˆä»…åœ¨ scan æˆ– continue æ¨¡å¼ä¸‹ï¼‰
                const triggered = await triggerContinuation(issue, evaluation);
                if (triggered) results.continued++;
              } else if (mode === 'verify') {
                // éªŒæ”¶æ¨¡å¼ä¸‹æœªé€šè¿‡ï¼šæ·»åŠ è¯„è®ºè¯´æ˜
                console.log(`  âŒ éªŒæ”¶æœªé€šè¿‡ï¼Œå®Œæˆåº¦: ${evaluation.completion_percentage}%`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    "## âš ï¸ éªŒæ”¶æœªé€šè¿‡",
                    "",
                    `**å®Œæˆåº¦**: ${evaluation.completion_percentage}%`,
                    "",
                    "**æœªå®Œæˆé¡¹ç›®**:",
                    evaluation.pending_items.map(i => `- [ ] ${i}`).join('\n'),
                    "",
                    "**å»ºè®®ä¸‹ä¸€æ­¥**:",
                    evaluation.next_action,
                    "",
                    "---",
                    "> ğŸ” ç”± Vibe Continuous è‡ªåŠ¨éªŒæ”¶"
                  ].join("\n")
                });

                // æ·»åŠ éœ€è¦ç»§ç»­çš„æ ‡ç­¾
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-review']
                });
              } else {
                console.log(`  â„¹ï¸ å®Œæˆåº¦: ${evaluation.completion_percentage}% (æ¨¡å¼: ${mode})`);
              }
            }

            // è¾“å‡ºæ±‡æ€»
            console.log("\n" + "=".repeat(60));
            console.log("ğŸ“Š æ£€æµ‹ç»“æœæ±‡æ€»");
            console.log("=".repeat(60));
            console.log(`  æ£€æµ‹: ${results.checked} ä¸ª`);
            console.log(`  å·²å®Œæˆ: ${results.completed} ä¸ª`);
            console.log(`  ç»§ç»­è¿­ä»£: ${results.continued} ä¸ª`);
            console.log(`  è·³è¿‡: ${results.skipped} ä¸ª`);
