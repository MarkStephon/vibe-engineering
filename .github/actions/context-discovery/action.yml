name: 'Smart Context Discovery'
description: 'æ™ºèƒ½ä¸Šä¸‹æ–‡å‘ç° - æ ¹æ® PRD å…³é”®è¯åŠ¨æ€å‘ç°ç›¸å…³ä»£ç æ–‡ä»¶'

inputs:
  requirement:
    description: 'PRD/éœ€æ±‚æ–‡æ¡£å†…å®¹'
    required: true
  target:
    description: 'ç›®æ ‡ç±»å‹: frontend | backend'
    required: true
    default: 'frontend'
  max_context_size:
    description: 'æœ€å¤§ä¸Šä¸‹æ–‡å¤§å°ï¼ˆå­—ç¬¦æ•°ï¼‰'
    required: false
    default: '15000'
  core_files:
    description: 'JSON æ•°ç»„æ ¼å¼çš„æ ¸å¿ƒæ–‡ä»¶åˆ—è¡¨ï¼ˆæ€»æ˜¯è¯»å–ï¼‰'
    required: false

outputs:
  context:
    description: 'å‘ç°çš„ä¸Šä¸‹æ–‡å†…å®¹ï¼ˆæ ¼å¼åŒ–åï¼‰'
    value: ${{ steps.discover.outputs.context }}
  discovered_files:
    description: 'å‘ç°çš„ç›¸å…³æ–‡ä»¶åˆ—è¡¨ï¼ˆJSON æ•°ç»„ï¼‰'
    value: ${{ steps.discover.outputs.discovered_files }}
  keywords:
    description: 'æå–çš„å…³é”®è¯åˆ—è¡¨'
    value: ${{ steps.discover.outputs.keywords }}
  stats:
    description: 'ä¸Šä¸‹æ–‡ç»Ÿè®¡ä¿¡æ¯'
    value: ${{ steps.discover.outputs.stats }}

runs:
  using: 'composite'
  steps:
    - name: Discover Context
      id: discover
      shell: bash
      env:
        REQUIREMENT: ${{ inputs.requirement }}
        TARGET: ${{ inputs.target }}
        MAX_SIZE: ${{ inputs.max_context_size }}
        CORE_FILES: ${{ inputs.core_files }}
      run: |
        node << 'NODEJS_SCRIPT'
        const fs = require('fs');
        const path = require('path');
        const { execSync } = require('child_process');

        const requirement = process.env.REQUIREMENT || '';
        const target = process.env.TARGET || 'frontend';
        const maxSize = parseInt(process.env.MAX_SIZE) || 15000;
        const coreFilesInput = process.env.CORE_FILES || '';

        console.log('='.repeat(60));
        console.log('ğŸ” SMART CONTEXT DISCOVERY');
        console.log('='.repeat(60));
        console.log(`ğŸ“ Target: ${target}`);
        console.log(`ğŸ“ Max context size: ${maxSize} chars`);

        // ============================================================
        // Layer 1: æ ¸å¿ƒæ–‡ä»¶ï¼ˆæ€»æ˜¯è¯»å–ï¼‰
        // ============================================================
        let coreFiles = [];

        if (coreFilesInput) {
          try {
            coreFiles = JSON.parse(coreFilesInput);
          } catch (e) {
            console.warn('âš ï¸ æ— æ³•è§£æ core_filesï¼Œä½¿ç”¨é»˜è®¤å€¼');
          }
        }

        if (coreFiles.length === 0) {
          if (target === 'frontend') {
            coreFiles = [
              'frontend/lib/routes.ts',
              'frontend/lib/api/types.ts',
              'frontend/lib/api/client.ts'
            ];
          } else {
            coreFiles = [
              'backend/internal/router/router.go',
              'backend/go.mod'
            ];
          }
        }

        console.log('\nğŸ“¦ Layer 1: Core Files');
        console.log(coreFiles.map(f => `  - ${f}`).join('\n'));

        // ============================================================
        // Layer 2: ä»éœ€æ±‚ä¸­æå–å…³é”®è¯
        // ============================================================
        console.log('\nğŸ”‘ Layer 2: Keyword Extraction');

        // å¸¸è§åœç”¨è¯
        const stopWords = new Set([
          'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
          'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
          'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',
          'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as',
          'into', 'through', 'during', 'before', 'after', 'above', 'below',
          'and', 'or', 'but', 'if', 'then', 'else', 'when', 'where', 'why',
          'how', 'all', 'each', 'every', 'both', 'few', 'more', 'most',
          'other', 'some', 'such', 'no', 'not', 'only', 'same', 'so', 'than',
          'too', 'very', 'just', 'also', 'now', 'here', 'there', 'this', 'that',
          'çš„', 'æ˜¯', 'åœ¨', 'æœ‰', 'å’Œ', 'ä¸', 'æˆ–', 'äº†', 'ç€', 'è¿‡', 'æŠŠ', 'è¢«',
          'è®©', 'ç»™', 'ä»', 'åˆ°', 'å‘', 'å¯¹', 'äº', 'ä»¥', 'ä¸º', 'è€Œ', 'ä½†', 'å¦‚æœ',
          'é‚£ä¹ˆ', 'æ‰€ä»¥', 'å› ä¸º', 'è™½ç„¶', 'ä½†æ˜¯', 'è€Œä¸”', 'å¹¶ä¸”', 'æˆ–è€…', 'è¿˜æ˜¯',
          'å¯ä»¥', 'éœ€è¦', 'åº”è¯¥', 'å¿…é¡»', 'èƒ½å¤Ÿ', 'ä¸€ä¸ª', 'è¿™ä¸ª', 'é‚£ä¸ª', 'ä»€ä¹ˆ',
          'ä½¿ç”¨', 'å®ç°', 'åˆ›å»º', 'æ·»åŠ ', 'åˆ é™¤', 'ä¿®æ”¹', 'æ›´æ–°', 'æ˜¾ç¤º', 'å±•ç¤º',
          'åŠŸèƒ½', 'é¡µé¢', 'ç»„ä»¶', 'æŒ‰é’®', 'è¡¨æ ¼', 'åˆ—è¡¨', 'è¡¨å•', 'è¾“å…¥', 'è¾“å‡º',
          'page', 'component', 'button', 'form', 'input', 'output', 'list',
          'table', 'item', 'data', 'user', 'file', 'code', 'function', 'api'
        ]);

        // æå–æœ‰æ„ä¹‰çš„å…³é”®è¯
        const extractKeywords = (text) => {
          const words = text
            .toLowerCase()
            .replace(/[^\w\u4e00-\u9fa5\s-]/g, ' ')
            .split(/\s+/)
            .filter(w => w.length >= 3 && !stopWords.has(w));

          // ç»Ÿè®¡è¯é¢‘
          const freq = {};
          words.forEach(w => freq[w] = (freq[w] || 0) + 1);

          // æŒ‰é¢‘ç‡æ’åºï¼Œå– top 20
          return Object.entries(freq)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 20)
            .map(([word]) => word);
        };

        // æå–ç‰¹å®šçš„æŠ€æœ¯è¯æ±‡å’Œä¸šåŠ¡è¯æ±‡
        const extractTechTerms = (text) => {
          const patterns = [
            /\b([A-Z][a-z]+(?:[A-Z][a-z]+)+)\b/g,  // PascalCase
            /\b([a-z]+(?:[A-Z][a-z]+)+)\b/g,        // camelCase
            /\/([\w-]+)/g,                           // è·¯å¾„ç‰‡æ®µ
            /@[\w-]+\/[\w-]+/g,                      // åŒ…å
            /['"`]([\w-]+)['"`]/g                    // å¼•å·ä¸­çš„æ ‡è¯†ç¬¦
          ];

          const terms = new Set();
          patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
              const term = match[1] || match[0];
              if (term.length >= 3 && term.length <= 30) {
                terms.add(term.toLowerCase());
              }
            }
          });

          return Array.from(terms);
        };

        const keywords = [...new Set([
          ...extractKeywords(requirement),
          ...extractTechTerms(requirement)
        ])].slice(0, 30);

        console.log(`  Keywords: ${keywords.slice(0, 10).join(', ')}${keywords.length > 10 ? '...' : ''}`);

        // ============================================================
        // Layer 3: æ ¹æ®å…³é”®è¯æœç´¢ç›¸å…³æ–‡ä»¶
        // ============================================================
        console.log('\nğŸ” Layer 3: File Discovery');

        const searchDir = target === 'frontend' ? 'frontend' : 'backend';
        const discoveredFiles = new Set();

        // æœç´¢ç­–ç•¥ 1: æ–‡ä»¶ååŒ¹é…
        const findByName = (keyword) => {
          try {
            const result = execSync(
              `find ${searchDir} -type f \\( -name "*.tsx" -o -name "*.ts" -o -name "*.go" \\) 2>/dev/null | grep -i "${keyword}" | head -5`,
              { encoding: 'utf8', timeout: 5000 }
            ).trim().split('\n').filter(Boolean);
            return result;
          } catch (e) {
            return [];
          }
        };

        // æœç´¢ç­–ç•¥ 2: æ–‡ä»¶å†…å®¹åŒ¹é…ï¼ˆä½¿ç”¨ grepï¼‰
        const findByContent = (keyword) => {
          try {
            const result = execSync(
              `grep -rl "${keyword}" ${searchDir} --include="*.tsx" --include="*.ts" --include="*.go" 2>/dev/null | head -3`,
              { encoding: 'utf8', timeout: 5000 }
            ).trim().split('\n').filter(Boolean);
            return result;
          } catch (e) {
            return [];
          }
        };

        // åªæœç´¢ top 10 å…³é”®è¯ä»¥é¿å…è¶…æ—¶
        const searchKeywords = keywords.slice(0, 10);

        for (const keyword of searchKeywords) {
          if (keyword.length < 4) continue; // è·³è¿‡å¤ªçŸ­çš„å…³é”®è¯

          const byName = findByName(keyword);
          const byContent = findByContent(keyword);

          [...byName, ...byContent].forEach(f => {
            // æ’é™¤ node_modules å’Œæµ‹è¯•æ–‡ä»¶
            if (!f.includes('node_modules') &&
                !f.includes('.test.') &&
                !f.includes('.spec.') &&
                !f.includes('__tests__')) {
              discoveredFiles.add(f);
            }
          });
        }

        // æ·»åŠ ç»„ä»¶ç›®å½•ä¸‹çš„ index æ–‡ä»¶
        if (target === 'frontend') {
          try {
            const componentDirs = execSync(
              `find frontend/components -type d -mindepth 1 -maxdepth 1 2>/dev/null`,
              { encoding: 'utf8', timeout: 3000 }
            ).trim().split('\n').filter(Boolean);

            componentDirs.forEach(dir => {
              const indexFile = path.join(dir, 'index.tsx');
              if (fs.existsSync(indexFile)) {
                discoveredFiles.add(indexFile);
              }
            });
          } catch (e) {}
        }

        console.log(`  Found ${discoveredFiles.size} related files`);
        console.log([...discoveredFiles].slice(0, 5).map(f => `  - ${f}`).join('\n'));
        if (discoveredFiles.size > 5) {
          console.log(`  ... and ${discoveredFiles.size - 5} more`);
        }

        // ============================================================
        // è¯»å–æ–‡ä»¶å¹¶æ§åˆ¶ä¸Šä¸‹æ–‡å¤§å°
        // ============================================================
        console.log('\nğŸ“– Reading files...');

        const readFile = (filePath) => {
          try {
            if (fs.existsSync(filePath)) {
              return fs.readFileSync(filePath, 'utf8');
            }
          } catch (e) {}
          return null;
        };

        const truncateContent = (content, maxLen = 2000) => {
          if (content.length <= maxLen) return content;
          return content.substring(0, maxLen) + '\n// ... [truncated]';
        };

        let totalSize = 0;
        const contextParts = [];

        // é¦–å…ˆè¯»å–æ ¸å¿ƒæ–‡ä»¶
        console.log('\n  ğŸ“¦ Reading core files...');
        for (const filePath of coreFiles) {
          const content = readFile(filePath);
          if (content) {
            const truncated = truncateContent(content, 3000);
            contextParts.push({
              path: filePath,
              content: truncated,
              size: truncated.length,
              layer: 'core'
            });
            totalSize += truncated.length;
            console.log(`    âœ… ${filePath} (${truncated.length} chars)`);
          }
        }

        // ç„¶åè¯»å–å‘ç°çš„ç›¸å…³æ–‡ä»¶ï¼ˆæŒ‰å¤§å°é™åˆ¶ï¼‰
        console.log('\n  ğŸ“¦ Reading discovered files...');
        const sortedDiscovered = [...discoveredFiles]
          .filter(f => !coreFiles.includes(f))
          .slice(0, 15);  // æœ€å¤š 15 ä¸ªå‘ç°çš„æ–‡ä»¶

        for (const filePath of sortedDiscovered) {
          if (totalSize >= maxSize * 0.9) {
            console.log('    âš ï¸ Approaching size limit, stopping');
            break;
          }

          const content = readFile(filePath);
          if (content) {
            // æ ¹æ®å‰©ä½™ç©ºé—´å†³å®šæˆªæ–­é•¿åº¦
            const remainingSpace = maxSize - totalSize;
            const truncateLen = Math.min(1500, remainingSpace);
            const truncated = truncateContent(content, truncateLen);

            contextParts.push({
              path: filePath,
              content: truncated,
              size: truncated.length,
              layer: 'discovered'
            });
            totalSize += truncated.length;
            console.log(`    âœ… ${filePath} (${truncated.length} chars)`);
          }
        }

        // ============================================================
        // æ ¼å¼åŒ–è¾“å‡º
        // ============================================================
        const formattedContext = contextParts
          .map(({ path, content }) => {
            const ext = path.split('.').pop();
            const lang = ext === 'go' ? 'go' : 'typescript';
            return `## ${path}\n\`\`\`${lang}\n${content}\n\`\`\``;
          })
          .join('\n\n');

        const stats = {
          totalFiles: contextParts.length,
          coreFiles: contextParts.filter(p => p.layer === 'core').length,
          discoveredFiles: contextParts.filter(p => p.layer === 'discovered').length,
          totalSize: totalSize,
          maxSize: maxSize,
          keywordsUsed: searchKeywords.length
        };

        console.log('\nğŸ“Š Stats:');
        console.log(`  Total files: ${stats.totalFiles}`);
        console.log(`  Core files: ${stats.coreFiles}`);
        console.log(`  Discovered files: ${stats.discoveredFiles}`);
        console.log(`  Total size: ${stats.totalSize} / ${stats.maxSize} chars (${Math.round(stats.totalSize / stats.maxSize * 100)}%)`);

        // å†™å…¥ GitHub è¾“å‡º
        const outputFile = process.env.GITHUB_OUTPUT;
        if (outputFile) {
          const delimiter = 'EOF_' + Math.random().toString(36).substring(7);
          fs.appendFileSync(outputFile, `context<<${delimiter}\n${formattedContext}\n${delimiter}\n`);
          fs.appendFileSync(outputFile, `discovered_files=${JSON.stringify([...discoveredFiles])}\n`);
          fs.appendFileSync(outputFile, `keywords=${JSON.stringify(keywords)}\n`);
          fs.appendFileSync(outputFile, `stats=${JSON.stringify(stats)}\n`);
        }

        console.log('\nâœ… Context discovery complete');
        NODEJS_SCRIPT
